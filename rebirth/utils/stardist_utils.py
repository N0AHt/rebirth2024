# utilities for loading and using a stardist model

from stardist.models import StarDist2D
from csbdeep.utils import normalize
import pathlib
from tqdm import tqdm
import numpy as np
import cv2



class stardist():

    '''
    Class wrapper for a stardist model,     
    '''

    def __init__(self, modelpath):
        path = pathlib.Path(modelpath)
        self._model = StarDist2D(None, path.name, str(path.parent))
        self.prob_threshold: float = self._model.thresholds.prob
        self.nms_threshold: float = self._model.thresholds.nms
    
    def detect(self, batch):
        detections_list = []
        data_list = []
        for image in tqdm(batch):
            segmentation, data = self._model.predict_instances(image, prob_thresh=self.prob_threshold, nms_thresh=self.nms_threshold, predict_kwargs={"verbose": 0})
            detections_list.append(segmentation)
            data_list.append(data)
        return detections_list, data_list



# preprocessing data for use with stardist

# TODO: Fix this normaliser. if I try to use the metadata file it is useless. Maybe something here is broken
def normalizer(video):
    video = np.copy(video)
    vidType = video.dtype
    # type_string = getattr(np, vidType)
    # mini = int(min_quantile)
    # maxi = int(max_quantile)
    mini = np.quantile(video, 0.005).astype(vidType)
    maxi = np.quantile(video, 0.999).astype(vidType)

    np.clip(video, mini, maxi, video)
    video = (video - mini) / (maxi - mini)
    return video



# contour plotting functions:

def coordReshaper_CV_contours(coords):

    '''
    Reshape contours generated by StarDist for use with openCV's display contours function
    '''

    coords_reshaped = []
    for contour in np.flip(coords,1): #hard to find this solution - coords need to be flipped, they are read clockwise by openCV and I guess this is not how they are written by StarDist. Results in contours plotted transposed from desired without flipping array.:)
        for i in range(len(contour[0])):
            coords_reshaped.append([contour[0][i], contour[1][i]]) #instead of flipping, these can be read y,x too [i.e. coords_reshaped.append([contour[1][i], contour[0][i]])]
    
    cv_format_contours = (np.array(coords_reshaped).reshape((-1,1,2)).astype(np.int32)) #https://stackoverflow.com/questions/14161331/creating-your-own-contour-in-opencv-using-python
    return cv_format_contours


def generate_contours(image, detector):
    segmentation, data = detector._model.predict_instances(image, prob_thresh=detector.prob_threshold, nms_thresh=detector.nms_threshold, predict_kwargs={"verbose": 0})
    contours = coordReshaper_CV_contours(data['coord'])
    return contours


def visualise_all_contours_cv(image, cvContours, colour = None):
    '''
    Takes contours in opencv format and plots them over image
    https://stackoverflow.com/questions/57576686/how-to-overlay-segmented-image-on-top-of-main-image-in-python
    '''

    # image_contours = image.copy()
    if colour == None:
        colour = (0,255,255)
    # Iterate over all contours
    for i,c in enumerate(cvContours):
        try:
            
            #for different colours - can define colour in this loop for each contour
            
            # Outline contour in that colour on main image, line thickness=1
            cv2.drawContours(image,[c],-1,colour,1, cv2.LINE_8)
        except Exception as e:
            print(e)
            break